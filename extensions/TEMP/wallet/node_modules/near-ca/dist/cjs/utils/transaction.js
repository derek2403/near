"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPayload = toPayload;
exports.fromPayload = fromPayload;
exports.buildTxPayload = buildTxPayload;
exports.populateTx = populateTx;
exports.addSignature = addSignature;
exports.relaySignedTransaction = relaySignedTransaction;
exports.broadcastSignedTransaction = broadcastSignedTransaction;
const viem_1 = require("viem");
const network_1 = require("../network");
function toPayload(msgHash) {
    const bytes = (0, viem_1.isBytes)(msgHash) ? msgHash : (0, viem_1.toBytes)(msgHash);
    if (bytes.length !== 32) {
        throw new Error(`Payload must have 32 bytes: ${msgHash}`);
    }
    return Array.from(bytes);
}
function fromPayload(payload) {
    if (payload.length !== 32) {
        throw new Error(`Payload must have 32 bytes: ${payload}`);
    }
    // Convert number[] back to Uint8Array
    return (0, viem_1.toHex)(new Uint8Array(payload));
}
function buildTxPayload(serializedTx) {
    return toPayload((0, viem_1.keccak256)(serializedTx));
}
async function populateTx(tx, from, client) {
    const provider = client || network_1.Network.fromChainId(tx.chainId).client;
    const chainId = await provider.getChainId();
    if (chainId !== tx.chainId) {
        // Can only happen when client is provided.
        throw new Error(`client chainId=${chainId} mismatch with tx.chainId=${tx.chainId}`);
    }
    const transactionData = {
        nonce: tx.nonce ?? (await provider.getTransactionCount({ address: from })),
        account: from,
        to: tx.to,
        value: tx.value ?? 0n,
        data: tx.data ?? "0x",
    };
    const [estimatedGas, { maxFeePerGas, maxPriorityFeePerGas }] = await Promise.all([
        // Only estimate gas if not provided.
        tx.gas || provider.estimateGas(transactionData),
        provider.estimateFeesPerGas(),
    ]);
    return {
        ...transactionData,
        gas: estimatedGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        chainId,
    };
}
function addSignature({ transaction, signature, }) {
    const txData = (0, viem_1.parseTransaction)(transaction);
    const signedTx = {
        ...signature,
        ...txData,
    };
    return (0, viem_1.serializeTransaction)(signedTx);
}
/**
 * Relays signed transaction to Ethereum mem-pool for execution.
 * @param serializedTransaction - Signed Ethereum transaction.
 * @returns Transaction Hash of relayed transaction.
 */
async function relaySignedTransaction(serializedTransaction, wait = true) {
    const tx = (0, viem_1.parseTransaction)(serializedTransaction);
    const network = network_1.Network.fromChainId(tx.chainId);
    if (wait) {
        const hash = await network.client.sendRawTransaction({
            serializedTransaction,
        });
        console.log(`Transaction Confirmed: ${network.scanUrl}/tx/${hash}`);
        return hash;
    }
    else {
        network.client.sendRawTransaction({
            serializedTransaction,
        });
        return (0, viem_1.keccak256)(serializedTransaction);
    }
}
/**
 * Relays valid representation of signed transaction to Etherem mempool for execution.
 *
 * @param {TransactionWithSignature} tx - Signed Ethereum transaction.
 * @returns Hash of relayed transaction.
 */
async function broadcastSignedTransaction(tx) {
    const signedTx = addSignature(tx);
    return relaySignedTransaction(signedTx);
}
