"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Beta = void 0;
const viem_1 = require("viem");
const transaction_1 = require("./utils/transaction");
const types_1 = require("./types");
const request_1 = require("./utils/request");
function stripEip155Prefix(eip155Address) {
    return eip155Address.split(":").pop() ?? "";
}
/**
 * Features currently underdevelopment that will be migrated into the adapter class once refined.
 * These features are accessible through the adapter class as `adapter.beta.methodName(...)`
 */
class Beta {
    constructor(adapter) {
        this.adapter = adapter;
    }
    async handleSessionRequest(request) {
        const { chainId, request: { method, params }, } = request.params;
        console.log(`Session Request of type ${method} for chainId ${chainId}`);
        if (!(0, types_1.isSignMethod)(method)) {
            throw new Error(`Unsupported sign method ${method}: Available sign methods ${types_1.signMethods}`);
        }
        const { evmMessage, hashToSign } = await (0, request_1.requestRouter)({
            method,
            chainId: parseInt(stripEip155Prefix(chainId)),
            params,
        });
        console.log("Parsed Request:", evmMessage, hashToSign);
        return {
            nearPayload: await this.adapter.mpcContract.encodeSignatureRequestTx({
                path: this.adapter.derivationPath,
                payload: (0, transaction_1.toPayload)(hashToSign),
                key_version: 0,
            }),
            evmMessage,
            hashToSign,
        };
    }
    async respondSessionRequest(signature, transaction) {
        if (transaction) {
            const signedTx = (0, transaction_1.addSignature)({ transaction, signature });
            // Returns relayed transaction hash (without waiting for confirmation).
            return (0, transaction_1.relaySignedTransaction)(signedTx, false);
        }
        return (0, viem_1.serializeSignature)(signature);
    }
}
exports.Beta = Beta;
